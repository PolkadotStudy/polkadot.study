# Implementation

In the chapter of the tutorial you will create a fully working smart contract. Let's start with creation your first ink! smart contract:

```bash
cargo new automated_market_maker
```

ink! smart contract programming language is based on Rust and that is why the most important file where we will implement the whole business logic is based in `lib.rs` file. Helicopter view of the file `lib.rs` looks like below:

```rust
#![cfg_attr(not(feature = "std"), no_std)]

const PRECISION: u128 = 1_000_000;

#[ink::contract]
pub mod automated_market_maker {

    use ink_prelude::collections::BTreeMap;

    /// Section: Definition of a storage

    #[ink(impl)]
    impl AutomatedMarketMaker {

        /// Section: Constructor


        /// Section: Business logic and core functions like:
        /// -   Providing new liquidity to the pool
        /// -   Swap
        /// -   Removing liquidity from a pool
        /// -   Liquidity constant curve of a pool

    }

        /// Section: Utils, errors definitions

    }
}
```

Within ink! smart contract language, the utilization of the standard library is not permitted. This restriction is explicitly denoted through the inclusion of a fundamental declaration at the outset of each smart contract: `#![cfg_attr(not(feature = "std"), no_std)]`. This statement signifies that, in the absence of the "std" feature, the standard library is not accessible for use in the ink! smart contract environment.

## Definition of a storage

Storage in a smart contract is a place where data are stored, there is also an incentive to make it as light as possible due to cost - keeping data on a blockchain is expensive.

In order to hold information about `shares` we use [BTreeMap](https://paritytech.github.io/ink/ink_prelude/collections/btree_map/struct.BTreeMap.html) which works similarly to a mapping in Solidity - an ordered map based data structure. Please pay attention to the fact that `BTreeMap` comes from `ink_prelude` package, not Rust standard library

```rust
    /// Storage
    #[ink(storage)]
    #[derive(Default)]
    pub struct AutomatedMarketMaker {
        trading_fee: Balance, // Percent of trading fees charged on every trade
        token1_balance: BTreeMap<AccountId, Balance>, // Amount of token1 balance of each user
        token2_balance: BTreeMap<AccountId, Balance>, // Amount of token2 balance of each user
        pool_total_token1: Balance, // The amount of token1 locked in the pool
        pool_total_token2: Balance, // The amount of token2 locked in the pool
        total_shares: Balance, // Stores the total amount of share issued for the pool
        shares: BTreeMap<AccountId, Balance>, // Stores the share holding of each user
    }
```

## Constructor

Constructor is the hear of every smart contract. As a parameter to constructor our smart contract we pass information about fees.

```rust
/// Instantiating AMM instance
/// @param _fees: valid interval -> [0,1000)
#[ink(constructor)]
pub fn new(_fees: Balance) -> Self {
    Self {
        trading_fee: if _fees >= 1000 { 0 } else { _fees },
        ..Default::default()
    }
}
```

## Business logic and core functions

The core functions of every decentralized exchange are:

- deliver liquidity
- swap tokens
- withdraw liquidity

Let's start from a crucial subject in any decentralized exchange which is liquidity, below we can see the function responsible for providing liquidity:

```rust
#[ink(message)]
pub fn provide_liquidity(
    &mut self,
    _amount_token1: Balance,
    _amount_token2: Balance,
) -> Result<Balance, Error>
```

In `ink!` smart contract programming language every public function has to have `#[ink(message)]` annotation. There need to be at least one public method in a smart contract.

`swap` feature is the most complex one in the smart contract and due to a need for estimation firstly of possibility a given swap it is implemented two functions `estimate_swap_token1_for_given_token1` and `estimate_swap_token1_for_given_token2`.

`withdraw` function is quite intuitive where we check firstly validation of the process with `check_valid_amount` to be sure that some user is not able to withdraw more money that it is previously delivered.

## Errors definitions and utils

Rust does not have traditional exceptions like those found in languages such as Java or Python. Instead, Rust relies on the `Result` and `Option` types for error handling and handling absence of values, respectively.

```rust
    /// Errors definitions
    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum Error {
        PoolDepleted(String),
        ZeroAmountErr(String),
        InvalidShareErr(String),
        ZeroLiquidityErr(String),
        SlippageExceededErr(String),
        InsufficientAmountErr(String),
        NonEquivalentValueErr(String),
        ThresholdNotReachedErr(String),
        InsufficientLiquidityErr(String),
    }
```

In the smart contract is implement some functions that are not strictly needed but helpful for testing, for example a place where a software engineer is able to generate tokens for tests - `faucet_brrr`. To follow K curve in an automated market maker is implemented `get_k` function. To get information about portfolio is implemented `get_information_portfolio` function and for pools information `get_pool_details`.

## Additional information

More information regarding ink! smart contracts programming language you will find in the [documentation](https://use.ink).

It's important to note that DEX development involves complex engineering challenges and requires a deep understanding of blockchain technology, cryptography, and security practices.
Collaboration with blockchain experts and continuous learning about evolving protocols and standards is essential in building a successful decentralized exchange.

While smart contracts are designed to be immutable, there are situations where it becomes necessary to make changes or upgrades to them. Developers may encounter scenarios where they need to address critical bugs or introduce additional features.

In order to build the whole smart contract use following commands:
```bash
git clone git@github.com:TomaszWaszczyk/ink-automated-market-maker.git
cd ink-automated-market-maker/automated-market-maker
cargo +nightly build --release
```

The project uses also `cargo fmt` tool in order to deliver well formatted source code, details how to use the tool you can find in the [link.](https://github.com/rust-lang/rustfmt)

If you are interested in more learning and development of the smart contract one of the option is to implement `proxy pattern`. That is an example of improvement proposal that actually adds real value.

## Github repository

I encourage you to explore the whole source code of [the decentralized exchange](https://github.com/TomaszWaszczyk/ink-automated-market-maker) code and unleash your creativity to enhance it. There is no better approach to learning than by actively engaging with the code, conducting experiments, and making improvements in a live environment.
