# Detailed explanation of the codebase
## Root Project

On the root project, some shorthand scripts inside [package.json](https://github.com/scio-labs/inkathon/blob/main/package.json#L15-L27) might be useful during development. These scripts facilitates on setting up the project and interacting with the dApp components (frontend and contract). They can also do linting, type-checking, and changeset.

## Frontend

We will discuss the important components inside this subdirectory.

On [src/deployments.ts](https://github.com/scio-labs/inkathon/blob/main/frontend/src/deployments/deployments.ts), all of the contracts in `/contracts` subdirectory are imported dynamically on the frontend. The [deployments](https://github.com/scio-labs/inkathon/blob/main/frontend/src/deployments/deployments.ts#L15C9-L15C20) object is then supplied into [ClientProviders](https://github.com/scio-labs/inkathon/blob/9703ab312fd93239b3b00ef669b91cc3b009789d/frontend/src/app/layout.tsx#L50-L53), wrapping the children on the root layout of the app.

On [chain-info.ts](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/chain-info.tsx), [useInkathon](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/chain-info.tsx#L13) hook is used to get [activeChain](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/chain-info.tsx#L13) which will then be displayed on the widget.

On [greeter-contract-interactions.ts](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/greeter-contract-interactions.tsx), [useRegisteredContract](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/greeter-contract-interactions.tsx#L27C50-L27C69) hook is used to access the contract, where then it can be utilised to fetch and update the greeting. Recently, we have also added fully-typed safety interactions via [useRegisteredTypedContract](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/greeter-contract-interactions.tsx#L28).

Lastly, [contractTxWithToast](https://github.com/scio-labs/inkathon/blob/main/frontend/src/components/web3/greeter-contract-interactions.tsx#L72) is also interesting to look at. It will show different toasters on the UI depending on the transaction status (e.g. “no gas status”, “transaction cancelled”, loader during “transaction submission”, “transaction successful”, etc.)

## Contracts

Although it is basically a Rust project, we want to make life easier for new devs, and that is why we again create some short-hand scripts inside [contracts/package.json](https://github.com/scio-labs/inkathon/blob/main/contracts/package.json). Here are some of the important stuff you need to know on this subdirectory.

One of the scripts can help you deploy contracts with just two lines of code, which can be found on [deploy.ts](https://github.com/scio-labs/inkathon/blob/main/contracts/scripts/deploy.ts#L22-L23).

The [/deployments/greeter](https://github.com/scio-labs/inkathon/tree/main/contracts/deployments) directory contains files with `.contract`, `.wasm`, and `.json` extensions, and are essentials to let the ink!athon dApp get the deployments of contracts and interact with them. 

There are also some files named to the chains where contracts were deployed, one of the example is [alephzero-testnet.ts](https://github.com/scio-labs/inkathon/blob/main/contracts/deployments/greeter/alephzero-testnet.ts). It means that we have deployed a contract on the `alephzero-testnet` before, and inside the corresponding file you can see the `address` of the deployed contract, and the `blockNumber` in which the contract were deployed. This info would be handy when you want to tinker more with the contract, probably via explorers or Contracts-UI. 

Another nice thing about this setup is that you could create a `development.ts` file, put it into `.gitignore` and deploy contracts on your local node, without having to worry about merge conflicts with other devs.

ℹ️ The files inside said folder can be easily generated by executing `build-all.sh`.

ℹ️ Any modifications on the contracts subdirectory will be imported automatically by the frontend side, so it eliminates the need to copy and paste files numerous times during the development.

### What about the Rust module (lib.rs)?

Let’s dissect the code in [src/greeter/lib.rs](https://github.com/scio-labs/inkathon/blob/main/contracts/src/greeter/lib.rs) to understand the logics of Greeter smart contract.

At the top, we have some ink!-specific macro `#![cfg_attr(not(feature = "std"), no_std, no_main)]` which adds normal Rust modules into the smart contract. Read this [discussion](https://substrate.stackexchange.com/questions/1274/why-do-we-need-cfg-attrnotfeature-std-no-std) if you want to understand deeper about it.

Then, we have [#[ink::contract] macro](https://use.ink/macros-attributes/contract/) which is the entry point for the smart contract and applied to Greeter module.

Going down, we see [#[ink(event)] macro](https://use.ink/macros-attributes/event/) which is applied to `Greeted` struct. It is optional but is important for indexing events.

We also can see [#[ink(storage)]](https://use.ink/macros-attributes/storage) macro which is applied to `Greeter` struct, and stores the greeting `message` in string.
One important macro is the [#[ink(constructor)] macro](https://use.ink/macros-attributes/constructor), which is applied to a function that initialises a new greeter contract with the given value, and to another which sets a `default_message`. Another important one is [#[ink(message)] macro](https://use.ink/macros-attributes/message/), which applies to `greet` and `set_message` methods. It is important to note that **there should be at least one method applied for each of these macros inside a contract module (otherwise the contract will not compile).**

Well done, now you have understood better how the boilerplate works! Bigger challenge ahead: extending the dApp with a new feature.